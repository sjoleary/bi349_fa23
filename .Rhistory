mutate(across(c(id, fips, zcta), as.factor)) %>%
mutate(city = case_when(city == "Not in a city" ~ "Not in a city",
city != "Not in a city" ~ "In a city"))
install.packages("doParallel")
library(doParallel)
RF_rec <- recipe(train_pm) %>%
update_role(everything(), new_role = "predictor")%>%
update_role(value, new_role = "outcome")%>%
update_role(id, new_role = "id variable") %>%
update_role("fips", new_role = "county id") %>%
step_novel("state") %>%
step_string2factor("state", "county", "city") %>%
step_rm("county") %>%
step_rm("zcta") %>%
step_corr(all_numeric())%>%
step_nzv(all_numeric())
# split sample
pm_split <- rsample::initial_split(data = pm, prop = 2/3)
# check proportions of split
pm_split
# training data set
train_pm <- training(pm_split)
# test data set
test_pm <- testing(pm_split)
RF_rec <- recipe(train_pm) %>%
update_role(everything(), new_role = "predictor")%>%
update_role(value, new_role = "outcome")%>%
update_role(id, new_role = "id variable") %>%
update_role("fips", new_role = "county id") %>%
step_novel("state") %>%
step_string2factor("state", "county", "city") %>%
step_rm("county") %>%
step_rm("zcta") %>%
step_corr(all_numeric())%>%
step_nzv(all_numeric())
RF_PM <- rand_forest(mtry = 10, min_n = 3) %>%  # specify model
set_engine("randomForest") %>%                  # set engine
set_mode("regression")                          # set mode (continuous - regression)
RF_PM
# specify workflow
RF_wflow <- workflows::workflow() %>%
workflows::add_recipe(RF_rec) %>%
workflows::add_model(RF_PM)
RF_wflow
RF_wflow_fit <- fit(RF_wflow, data = train_pm)
RF_wflow_fit %>%
pull_workflow_fit() %>%
vip(num_features = 10)
install.packages("randomForest")
library(randomForest)
RF_wflow_fit <- fit(RF_wflow, data = train_pm)
RF_wflow_fit %>%
pull_workflow_fit() %>%
vip(num_features = 10)
# create four subsets
kfold_pm <- rsample::vfold_cv(data = train_pm, v = 4)
# perform cross-validation
xVal_RF <- tune::fit_resamples(RF_wflow, kfold_pm)
# print rmse and rsq
collect_metrics(xVal_RF)
# print rmse and rsq
collect_metrics(xVal)
# print rmse and rsq
collect_metrics(xVal_RF)
tune_RF <- rand_forest(mtry = tune(), min_n = tune()) %>%
set_engine("randomForest") %>%
set_mode("regression")
tune_RF
RF_tune_wflow <- workflows::workflow() %>%
workflows::add_recipe(RF_rec) %>%
workflows::add_model(tune_RF)
RF_tune_wflow
detectCores()
# specify number of cores to use
doParallel::registerDoParallel(cores = 2)
# tune parameters using 20 values per parameter
tune_RF_results <- tune_grid(object = RF_tune_wflow, resamples = kfold_pm, grid = 20)
tune_RF_results
#| label: setup
#| include: false
# custom functions ----
library(ggplot2)
theme_standard <- theme_classic() +
theme(
axis.text = element_text(size = 11, color = "black"),
axis.title = element_text(size = 16, color = "black"),
axis.title.y = element_text(vjust = 1.5, color = "black"),
axis.line = element_line(color = "black"),
legend.position = "bottom",
panel.background = element_rect(fill = "white", color = NA),
panel.border = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
strip.background = element_rect(fill = "grey95", color = "black"),
strip.text.x = element_text(size = 16, color = "black"),
strip.text.y = element_text(size = 16, color = "black"))
theme_facet <- theme_classic() +
theme(
axis.text = element_text(size = 11, color = "black"),
axis.title = element_text(size = 16, color = "black"),
axis.title.y = element_text(vjust = 1.5, color = "black"),
axis.line = element_line(color = "black"),
legend.position = "bottom",
panel.background = element_rect(fill = "white", color = NA),
panel.border = element_rect(fill = NA, color = "black"),
panel.grid.major = element_line(color = "grey85"),
panel.grid.minor = element_blank(),
strip.background = element_rect(fill = "grey95", color = "black"),
strip.text.x = element_text(size = 16, color = "black"),
strip.text.y = element_text(size = 16, color = "black"))
# set options
knitr::opts_chunk$set(
tidy = FALSE,
message = FALSE,
warning = FALSE)
options(htmltools.dir.version = FALSE)
theme_set(theme_standard)
#| label: setup
#| include: false
# custom functions ----
library(ggplot2)
theme_standard <- theme_classic() +
theme(
axis.text = element_text(size = 11, color = "black"),
axis.title = element_text(size = 16, color = "black"),
axis.title.y = element_text(vjust = 1.5, color = "black"),
axis.line = element_line(color = "black"),
legend.position = "bottom",
panel.background = element_rect(fill = "white", color = NA),
panel.border = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
strip.background = element_rect(fill = "grey95", color = "black"),
strip.text.x = element_text(size = 16, color = "black"),
strip.text.y = element_text(size = 16, color = "black"))
theme_facet <- theme_classic() +
theme(
axis.text = element_text(size = 11, color = "black"),
axis.title = element_text(size = 16, color = "black"),
axis.title.y = element_text(vjust = 1.5, color = "black"),
axis.line = element_line(color = "black"),
legend.position = "bottom",
panel.background = element_rect(fill = "white", color = NA),
panel.border = element_rect(fill = NA, color = "black"),
panel.grid.major = element_line(color = "grey85"),
panel.grid.minor = element_blank(),
strip.background = element_rect(fill = "grey95", color = "black"),
strip.text.x = element_text(size = 16, color = "black"),
strip.text.y = element_text(size = 16, color = "black"))
theme_set(theme_standard)
# load libraries ----
# reporting
library(knitr)
# visualization
library(ggplot2)
library(ggthemes)
library(patchwork)
# data wrangling
library(dplyr)
library(tidyr)
library(readr)
library(skimr)
library(janitor)
library(magrittr)
library(lubridate)
# modelling
library(tidymodels)
# set other options ----
options(scipen=999)
knitr::opts_chunk$set(
tidy = FALSE,
message = FALSE,
warning = FALSE)
# specify number of cores to use
doParallel::registerDoParallel(cores = 2)
# read & wrangle data set
pm <- read_delim("data/air_pollution.csv", delim = ",") %>%
clean_names() %>%
mutate(across(c(id, fips, zcta), as.factor)) %>%
mutate(city = case_when(city == "Not in a city" ~ "Not in a city",
city != "Not in a city" ~ "In a city"))
# split sample
pm_split <- rsample::initial_split(data = pm, prop = 2/3)
# extract training data set
train_pm <- training(pm_split)
# extract test data set
test_pm <- testing(pm_split)
# recipe to pre-process data set
RF_rec <- recipe(train_pm) %>%
update_role(everything(), new_role = "predictor")%>%
update_role(value, new_role = "outcome")%>%
update_role(id, new_role = "id variable") %>%
update_role("fips", new_role = "county id") %>%
step_novel("state") %>%
step_string2factor("state", "county", "city") %>%
step_rm("county") %>%
step_rm("zcta") %>%
step_corr(all_numeric())%>%
step_nzv(all_numeric())
# specify model to tune parameters
tune_RF <- rand_forest(mtry = tune(), min_n = tune()) %>%
set_engine("randomForest") %>%
set_mode("regression")
# specify workflow
RF_wflow <- workflows::workflow() %>%
workflows::add_recipe(RF_rec) %>%
workflows::add_model(RF_PM) %>%
workflows::add_recipe(RF_rec) %>%
workflows::add_model(tune_RF)
# split data for cross-validation
kfold_pm <- rsample::vfold_cv(data = train_pm, v = 4)
# tune parameters using 20 values per parameter
tune_RF_results <- tune_grid(object = RF_tune_wflow, resamples = kfold_pm, grid = 20)
# tune parameters using 20 values per parameter
tune_RF_results <- tune_grid(object = RF_tune_wflow, resamples = kfold_pm, grid = 20)
# specify workflow
RF_tune_wflow <- workflows::workflow() %>%
workflows::add_recipe(RF_rec) %>%
workflows::add_model(RF_PM) %>%
workflows::add_recipe(RF_rec) %>%
workflows::add_model(tune_RF)
# tune parameters using 20 values per parameter
tune_RF_results <- tune_grid(object = RF_tune_wflow, resamples = kfold_pm, grid = 20)
# specify workflow
RF_tune_wflow <- workflows::workflow() %>%
workflows::add_recipe(RF_rec) %>%
workflows::add_model(tune_RF)
# split data for cross-validation
kfold_pm <- rsample::vfold_cv(data = train_pm, v = 4)
# tune parameters using 20 values per parameter
tune_RF_results <- tune_grid(object = RF_tune_wflow, resamples = kfold_pm, grid = 20)
# pull the optimal model parameters
tuned_RF_values<- select_best(tune_RF_results, "rmse")
# define workflow using optimized parameters
RF_tuned_wflow <-RF_tune_wflow %>%
tune::finalize_workflow(tuned_RF_values)
# build final model using training data and predict testing data
overallfit <- RF_wflow %>%
tune::last_fit(pm_split)
#| label: setup
#| include: false
# custom functions ----
library(ggplot2)
theme_standard <- theme_classic() +
theme(
axis.text = element_text(size = 11, color = "black"),
axis.title = element_text(size = 16, color = "black"),
axis.title.y = element_text(vjust = 1.5, color = "black"),
axis.line = element_line(color = "black"),
legend.position = "bottom",
panel.background = element_rect(fill = "white", color = NA),
panel.border = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
strip.background = element_rect(fill = "grey95", color = "black"),
strip.text.x = element_text(size = 16, color = "black"),
strip.text.y = element_text(size = 16, color = "black"))
theme_facet <- theme_classic() +
theme(
axis.text = element_text(size = 11, color = "black"),
axis.title = element_text(size = 16, color = "black"),
axis.title.y = element_text(vjust = 1.5, color = "black"),
axis.line = element_line(color = "black"),
legend.position = "bottom",
panel.background = element_rect(fill = "white", color = NA),
panel.border = element_rect(fill = NA, color = "black"),
panel.grid.major = element_line(color = "grey85"),
panel.grid.minor = element_blank(),
strip.background = element_rect(fill = "grey95", color = "black"),
strip.text.x = element_text(size = 16, color = "black"),
strip.text.y = element_text(size = 16, color = "black"))
theme_set(theme_standard)
# load libraries ----
# reporting
library(knitr)
# visualization
library(ggplot2)
library(ggthemes)
library(patchwork)
# data wrangling
library(dplyr)
library(tidyr)
library(readr)
library(skimr)
library(janitor)
library(magrittr)
library(lubridate)
# modelling
library(tidymodels)
# set other options ----
options(scipen=999)
knitr::opts_chunk$set(
tidy = FALSE,
message = FALSE,
warning = FALSE)
# specify number of cores to use
doParallel::registerDoParallel(cores = 2)
# read & wrangle data set
pm <- read_delim("data/air_pollution.csv", delim = ",") %>%
clean_names() %>%
mutate(across(c(id, fips, zcta), as.factor)) %>%
mutate(city = case_when(city == "Not in a city" ~ "Not in a city",
city != "Not in a city" ~ "In a city"))
# split sample ----
pm_split <- rsample::initial_split(data = pm, prop = 2/3)
# extract training data set
train_pm <- training(pm_split)
# extract test data set
test_pm <- testing(pm_split)
# split data for cross-validation
kfold_pm <- rsample::vfold_cv(data = train_pm, v = 4)
# ceate recipe to pre-process data set and assign variable roles
RF_rec <- recipe(train_pm) %>%
update_role(everything(), new_role = "predictor")%>%
update_role(value, new_role = "outcome")%>%
update_role(id, new_role = "id variable") %>%
update_role("fips", new_role = "county id") %>%
step_novel("state") %>%
step_string2factor("state", "county", "city") %>%
step_rm("county") %>%
step_rm("zcta") %>%
step_corr(all_numeric())%>%
step_nzv(all_numeric())
# specify model, engine, and mode and hyperparameters to tune
tune_RF <- rand_forest(mtry = tune(), min_n = tune()) %>%
set_engine("randomForest") %>%
set_mode("regression")
# specify workflow with recipe and model to be used
RF_tune_wflow <- workflows::workflow() %>%
workflows::add_recipe(RF_rec) %>%
workflows::add_model(tune_RF)
# fit workflow with cross validation and tuning
tune_RF_results <- tune_grid(object = RF_tune_wflow, resamples = kfold_pm, grid = 20)
# get performance metrics and pull out the optimal model parameters
tuned_RF_values<- select_best(tune_RF_results, "rmse")
# define workflow using optimized parameters
RF_tuned_wflow <-RF_tune_wflow %>%
tune::finalize_workflow(tuned_RF_values)
world <- ne_countries(scale = "medium", returnclass = "sf")
library(rnaturalearth)
world <- ne_countries(scale = "medium", returnclass = "sf")
#| label: fig-world
#| fig-cap-location: bottom
#| fig-cap: "World map"
# fill
map_color <- "darkkhaki"
# plot world map
ggplot() +
geom_sf(data = world, color = "black", fill = map_color)
#| label: fig
#| fig-cap-location: bottom
#| fig-cap: "Map of the continental United States
# lat/long for map extent
x_min <- -124.7844079
x_max <- -66.9513812
y_min <- 24.7433195
y_max <- 49.3457868
# set color for fill
map_color <- "khaki3"
# create plot
ggplot() +
geom_sf(data = world, color = "black", fill = map_color) +  # plot outline of countries
coord_sf(xlim = c(x_min, x_max),
ylim = c(y_min, y_max))                            # set boundaries for map
#| label: fig-US-sites
#| fig-cap-location: bottom
#| fig-cap: "MMap of continential United States indicating county lines.
# create plot
ggplot() +
geom_sf(data = world, color = "black", fill = map_color) +  # plot outline of countries
geom_point(data = pm, aes(x = lon, y = lat),                # add sites
size = 2, shape = 23, fill = "darkred") +
coord_sf(xlim = c(x_min, x_max),
ylim = c(y_min, y_max))
#| label: fig-US-sites
#| fig-cap-location: bottom
#| fig-cap: "Air pollution monitoring in the United States. Red diamaonds indicate individual monitoring sites."
# create plot
ggplot() +
geom_sf(data = world, color = "black", fill = map_color) +  # plot outline of countries
geom_point(data = pm, aes(x = lon, y = lat),                # add sites
size = 2, shape = 23, fill = "darkred") +
coord_sf(xlim = c(x_min, x_max),
ylim = c(y_min, y_max))
library(maps)
install.packages("maps")
library(maps)
# download counties
counties <- map("county", plot = FALSE, fill = TRUE) %>%
st_as_sf()
# maps
library(sf)
# download counties
counties <- map("county", plot = FALSE, fill = TRUE) %>%
st_as_sf()
# object information
counties
# download counties
counties <- map("county", plot = FALSE, fill = TRUE) %>%
st_as_sf()
# object information
counties
#| label: fig-air-poll-US
#| fig-cap-location: bottom
#| fig-cap: "Air pollution monitoring system in continental US. Individual monitors are indicated by a red diamond."
# create plot
ggplot() +
geom_sf(data = world, color = "black", fill = map_color) +  # plot outline of countries
geom_sf(data = counties, fill = NA, color = "black") +      # add county lines
geom_point(data = pm, aes(x = lon, y = lat),                # add sites
size = 2, shape = 23, fill = "darkred") +
coord_sf(xlim = c(x_min, x_max),
ylim = c(y_min, y_max)) +
labs(title = "Air pollution monitor locations")
# set color for fill
map_color <- "khaki"
# create plot
ggplot() +
geom_sf(data = world, color = "black", fill = map_color) +  # plot outline of countries
coord_sf(xlim = c(x_min, x_max),
ylim = c(y_min, y_max))                            # set boundaries for map
#| label: fig-air-poll-US
#| fig-cap-location: bottom
#| fig-cap: "Air pollution monitoring system in continental US. Individual monitors are indicated by a red diamond."
# create plot
ggplot() +
geom_sf(data = world, color = "black", fill = map_color) +  # plot outline of countries
geom_sf(data = counties, fill = NA, color = "black") +      # add county lines
geom_point(data = pm, aes(x = lon, y = lat),                # add sites
size = 2, shape = 23, fill = "darkred") +
coord_sf(xlim = c(x_min, x_max),
ylim = c(y_min, y_max)) +
labs(title = "Air pollution monitor locations")
head(counties)
pm %>%
pull(county) %>%
head()
counties <- counties %>%
separate(ID, into = c("state", "county"), sep = ",", remove = FALSE) %>%
mutate(county = str_to_title(county))
library(stringr)
counties <- counties %>%
separate(ID, into = c("state", "county"), sep = ",", remove = FALSE) %>%
mutate(county = str_to_title(county))
head(counties)
map_data <- counties %>%
inner_join(pm, by = "county")
#| label: fig-pm-obs
#| fig-cap: "Observed mean annual PM2.5 concentration for counties with air pollution monitor."
p1 <- ggplot() +
geom_sf(data = world, color = "black", fill = NA) +
geom_sf(data = map_data, aes(fill = value), color = "black") +
scale_fill_viridis_c() +
coord_sf(xlim = c(x_min, x_max),
ylim = c(y_min, y_max)) +
labs(title = "Observed mean annual PM2.5 concentration")
p1
# fit model for monitors in training set
train_fit <- RF_tuned_wflow %>%
fit(data = train_pm)
# fit model for monitors in training set
test_fit <- RF_tuned_wflow %>%
fit(data = test_pm)
# predict values for monitors in training set
pred_train <- train_fit %>%
predict(train_pm) %>%
bind_cols(train_pm) %>%
select(.pred, value, fips, county, id)
# predict values for monitors in test set
pred_test <- test_fit %>%
predict(test_pm) %>%
bind_cols(test_pm) %>%
select(.pred, value, fips, county, id)
# combine data sets
pred_PM25 <- pred_test %>%
bind_rows(pred_train)
# add counties data for plotting
map_data <- counties %>%
inner_join(pred_PM25, by = "county")
p2 <- ggplot() +
geom_sf(data = world, color = "black", fill = NA) +
geom_sf(data = map_data, aes(fill = value), color = "black") +
scale_fill_viridis_c() +
coord_sf(xlim = c(x_min, x_max),
ylim = c(y_min, y_max)) +
labs(title = "Predicted mean annual PM2.5 concentration")
p2
#| label: fig-pm-pred
#| fig-cap: "Predicted mean annual PM2.5 concentration for counties with air pollution monitor."
p2 <- ggplot() +
geom_sf(data = world, color = "black", fill = NA) +
geom_sf(data = map_data, aes(fill = value), color = "black") +
scale_fill_viridis_c() +
coord_sf(xlim = c(x_min, x_max),
ylim = c(y_min, y_max)) +
labs(title = "Predicted mean annual PM2.5 concentration")
p2
#| label: fig-pm-pred-v-obs
#| fig-cap: "Comparison of observed and predicted mean annual PM2.5 concentration for counties with air pollution monitor."
#| fig-width: 9
#| fig-height: 15
p1 / p2 +
plot_annotation(title = "Comparison of observed (top) and predicted (bottom) PM2.5 levels.",
subtitle = "A random forest model was trained to predict air PM2.5 levels based on predictor \nvariables including population levels, road density, development")
# download counties
counties <- map("county", plot = FALSE, fill = TRUE) %>%
st_as_sf()
# object information
counties
# download counties
counties <- maps::map("county", plot = FALSE, fill = TRUE) %>%
st_as_sf()
